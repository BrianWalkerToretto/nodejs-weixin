{"./":{"url":"./","title":"前言","keywords":"","body":"Nodejs 开发微信公众号 本小书通过观看 scoot 视频课程《Node.js7天开发微信公众号》，经过学习并结合感受写下的，希望对正在学习这块知识的你能有所帮助。如果你也收益多多，请 --> star 目标 [x] 交互流程 [x] Nodejs 使用技巧 [x] 架构项目方式 [x] Koa 框架使用 [x] ES2015 新特性 实现功能 [x] 获取用户地理位置信息 [x] js sdk 的接入 [x] 菜单功能 [x] 文字回复 [x] 扫二维码、拍照和相册等 [x] 查询：文字和语音 设计技术栈及技术点 js sdk，公众号开发需要与公众号后台有交互，需要在后台网页进行配置，比如通信的域名地址，js sdk 授权地址等； yield，ES6 一些特性； koa，web 框架，用来处理服务器之间的应用初始化、接口调用及数据响应； bluebird，尽管 Promise 在高版本 nodejs 里已经提供，但还是引用 bluebird 处理和封装异步请求； request，网络请求，对原生 http request 的封装； ejs，微信的数据包装方式是 xml，借助 ejs 模板库，把数据作为变量替换到 xml 字符中； lodash，工具方法集，比如 heredoc 是一个黑科技，把函数体里面的多行注释作为字符串提取出来主要用来降低拼接字符串的成本; raw-body，用来获取一个 http 请求返回的可读流的内容实体； sha1，加密哈希算法库； xml2js，微信服务器返回的数据依然是 xml 格式，没发直接在 js 函数中使用，借助 xml2js 模块把 xml 数据解析为 js 对象，方便我们使用； 注意点 配置接入流程； 加密认证环节； access_token（凭据）的获取； 需具备 javascript 基础； 利用 Nodejs 开发一些网页或爬虫工具，来对 Nodejs API 和它的技术特点有一些基本的认知； 有一些其他的后端语言经验，无论是PHP/Java/Ruby 均可，主要整明白网络 http 请求从开始到结束中间所经过的环节； 文档和示例地址 github 地址 欢迎评论 你可以 下一篇：关于微信 Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2020-01-02 15:23:07 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"weixin.html":{"url":"weixin.html","title":"关于微信","keywords":"","body":"关于微信号一些说明（文档可能不是最新的） 微信号分类 订阅号，适合于个人、小团队，用于信息传播，帮助管理用户以及和用户互动，比如撰写文章、咨询传播、消息定制等； 服务号，适合于企业和组织，提供更强大的业务服务与用户管理能力，比如支付、智能接口等； 企业号，适合于企业或组织，提供移动应用入口，帮助企业建立与员工、上下游供应链及企业应用间的连接； 举个适用于学校、学院、班级的例子 分类 说明 订阅号 管理一个班级、一个学院的信息订阅，通知和互动 服务号 管理全学校的打印店等，可以直接支付送货上门，及时推送一些特价活动 企业号 管理全学校所有学院、团委、学生处各部门人员考勤、活动等 订阅号支持的常用接口 会话界面自定义菜单； 多客服接口； 获取用户地理位置； 高级群发接口； 用户分组； 9大接口 语音识别，即语音转文本； 客服接口，发过的消息 24 小时内回复消息； OAuth 2.0 网页授权，通过授权接口，请求用户授权，获取更多用户信息； 生成带参数的二维码，用户扫描关注公众号后根据参数分析各二维码的效果，从而可以实现更多分析结果； 获取用户地理位置； 获取用户信息； 获取关注者列表信息； 用户分组接口，通过分组接口，可以在后台为用户移动、创建、修改分组； 上传、下载多媒体文件； 订阅号和服务号不同 出现位置不同； 订阅号 1篇/天，服务号 4篇/月； 订阅号没有 9大接口和支付功能； 是否认证 认证，得需要有一个开户过的企业（也就是以公司名义），如果是服务号建议认证一下。订阅号认证账号别人可以直接在添加好友里搜索关键词就能找到你。 注意事项 微信公众号接口只支持 80 端口； 微信后台配置的 URL 是唯一能接收到消息和事件的入口，公众号所有操作都是基于这个 URL 进行交互的； 调用所有微信接口时几乎全部使用 https 协议； 用户向公众号发消息时，会传过来 openID，这个 openID 是用户微信号加密后的值，每个用户在每个公众号中 openID 是唯一的； 在开发阶段，要时刻留意报错信息，比如全局返回码，这个特别特别特别地重要，开发出了问题需要手动解决； 和微信服务器交互时，需要满足各个接口的规范限制、调用频率限制、模板消息、用户数据等敏感信息的使用规范； 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：Nodejs 开发微信公众号 下一篇：本地访问和外网访问 Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2020-01-02 15:22:42 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"local_internet.html":{"url":"local_internet.html","title":"本地访问和外网访问","keywords":"","body":"本地访问和外网访问 作为一个 Web 开发者，我们有时候会需要临时地将一个本地的 Web 网站部署到外网，以供他人访问、测试、调试等。你可以 购买域名和服务器 内网穿透 购买域名和服务器 找到一台运行于外网的 Web 服务器； 服务器上有网站所需要的环境，否则自行搭建； 将网站部署到服务器上； 调试结束后，再将网站从服务器上删除； 对应微信服务器实现流程【微信 - 微信的服务器 - 你的域名的服务器】； 如果是一个浏览网站，这么个流程一点儿问题都没有，但是现在的场景临时项目，只是访问、调试等，如此复杂步骤，实非所愿，耗费太多精力在部署环境上，累觉不爱。再看看另一种方式吧。 内网穿透 拿 ngrok 举例，类似软件会很多。你会发现：有了 ngrok 之后，世界是如此美好。 ngrok ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。 反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如 Web 服务器）上获取资源，然后再将这些资源返回给客户端。也就是说客户端只知道代理的IP地址，不知道代理服务器后面的服务器集群的存在。比如 CDN。 顺便再说下前向代理，它是代理客户端的一种。客户端借由前向代理可以间接访问很多不同互联网服务器（集群）的资源，服务端（如Web服务器）只知道代理的 IP 地址，不知道代理客户端的 IP 地址。 实现流程 微信 - 微信的服务器 - 内网穿透的域名的服务器 - 内网穿透工具通道 - 本地代理服务 具体实现 1.本地起个服务 python -m SimpleHTTPServer 1989 本地访问 http://localhost:1989，此刻也就限于你自己访问。 2.ngrok（花生壳、localtunnel）等工具实现 ./ngrok http 1989 3.外网查看 此刻，任何人访问 https://1922e6ad.ngrok.io，都可以看到你本地 http://localhost:1989 所启服务的内容了。 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：关于微信 下一篇：小试编码 Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2020-01-02 20:14:36 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"code.html":{"url":"code.html","title":"小试编码","keywords":"","body":"小试编码 版本一，测通公众号 配置测试公众号 1.进入微信官方文档（公众号）; 2.接口测试号申请，微信公众号的注册有一定门槛，可以用测试账号，我们的目的是为了尝试编程，要明白真正要关注的点。 3.测试账号管理 Token- ruizhengyunpr840690384 验证公众号 交互：微信 -> token、timestamp、nonce 字典排序 -> 拼接为字符串再 sha1 加密 -> (result === signature) -> return echostr 将 token、timestamp、nonce 三个参数进行字典排序； 将三个参数字符串拼接成一个字符串进行 sha1 加密； 将加密后的字符串与 signature 对比，如果相同，表示这个请求来源于微信，直接原样返回 echostr 参数内容，接入验证就成功了； 代码实现 1.启动项文件 // app-1.js /** * @创建码农: pr * @创建日期: 2019-12-26 19:47:02 * @最近更新: pr * @更新时间: 2019-12-26 19:47:02 * @文件描述: 启动项文件 */ const Koa = require('koa'); const sha1 = require('sha1'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384' } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(function*(next) { console.log('query', this.query); const token = config.wechat.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { this.body = echostr + ''; } else { this.body = '不是来源于微信'; } }); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.启动本地服务 node --harmony app-1.js 3.ngrok 启动代理本地服务 ./ngrok http 1989 4.拷贝 ngrok 产生的 https 地址到微信公众号 > 接口配置信息 > URL 中，然后点击 提交，结果如下 5.查看本地服务控制台 版本二，抽取公众号参数的校验中间件 版本一，我们实现了微信公众号验证成功，本着专业人做专业事，单一文件实现单一功能的原则，可以将中间件抽离处理独立成为一个文件，然后启动项文件引入传参再调用。 代码实现 1.启动项文件 // app-2.js /** * @创建码农: pr * @创建日期: 2019-12-27 19:47:02 * @最近更新: pr * @更新时间: 2019-12-27 19:47:02 * @文件描述: 启动项文件，版本二 */ const Koa = require('koa'); const weChatMiddleWare = require('./app-2/weChat'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384' } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.中间件 // app-2/weChat.js /** * @创建码农: pr * @创建日期: 2019-12-27 19:47:02 * @最近更新: pr * @更新时间: 2019-12-27 19:47:02 * @文件描述: 公众号校验中间件 */ const sha1 = require('sha1'); // 中间件 module.exports = function(opts) { return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { console.log('来源于微信'); this.body = echostr + ''; } else { console.log('不是来源于微信'); this.body = '不是来源于微信'; } }; }; 3.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址，然后是否公众号是否验证成功。这个版本只是改写，并未产生新的功能代码，所以没什么难题。 版本三，解决 access_token（凭证）失效问题 access_token 特性 access_token 每2小时（7200秒）自动失效，需要重新获取； 只要更新了 access_token，之前的 access_token 就没用了； 设计方案 系统每隔 2 小时启动去刷新一次 access_token，这样无论什么时候调用接口，都是最新的； 为了方便频繁调用，所以的把更新 access_token 存储在一个唯一的地方（一定不要存内存）； 代码实现 1.启动项，这块要建个 /app-3/config/access-token.txt // app-3.js /** * @创建码农: pr * @创建日期: 2019-12-28 19:47:02 * @最近更新: pr * @更新时间: 2019-12-28 19:47:02 * @文件描述: 启动项文件，版本三 */ const Koa = require('koa'); const path = require('path'); const util = require('./app-3/util'); const weChatMiddleWare = require('./app-3/weChat'); const wechat_file = path.join(__dirname, './app-3/config/access-token.txt'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384', getAccessToken: () => { return util.readFileAsync(wechat_file); }, saveAccessToken: data => { data = JSON.stringify(data); return util.writeFileAsync(wechat_file, data); } } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.中间件 // app-3/util.js /** * @创建码农: pr * @创建日期: 2019-12-28 19:47:02 * @最近更新: pr * @更新时间: 2019-12-28 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const sha1 = require('sha1'); const Promise = require('bluebird'); const request = Promise.promisify(require('request')); // 参数定义 const prefix = 'https://api.weixin.qq.com/cgi-bin/'; const api = { accessToken: `${prefix}token?grant_type=client_credential` }; // 判断 access_token 是否过期 function AccessTokenInfo(opts) { const that = this; this.appID = opts.appID; this.appSecret = opts.appSecret; this.getAccessToken = opts.getAccessToken; this.saveAccessToken = opts.saveAccessToken; that .getAccessToken() .then(function(data) { try { data = JSON.parse(data); } catch (e) { // 不合法就重新更新 access_token return that.updateAccessToken(); } if (that.isValidAccessToken(data)) { // 判断是否有效 return Promise.resolve(data); } else { // 不合法就重新更新 access_token return that.updateAccessToken(); } }).then(data => { // 取到合法 access_token that.access_token = data.access_token; that.expires_in = data.expires_in; that.saveAccessToken(data); }); } // 验证 access_token 是否有效 AccessTokenInfo.prototype.isValidAccessToken = function(data) { if (!data || !data.access_token || !data.expires_in) { return false; } const now = new Date().getTime(); if (now { request({ url, json: true }).then(res => { const data = res.body; console.log('data', data); const now = new Date().getTime(); // 缩短 20 秒（算上网络请求时间） const expires_in = now + (data.expires_in - 20) * 1000; data.expires_in = expires_in; resolve(data); }); }); }; // 中间件 module.exports = function(opts) { const accessTokenInfo = new AccessTokenInfo(opts); return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); if (sha === signature) { console.log('来源于微信'); this.body = echostr + ''; } else { console.log('不是来源于微信'); this.body = '不是来源于微信'; } }; }; 3.编写工具库 /** * @创建码农: 芮正云 16396@etransfar.com * @创建日期: 2019-12-28 16:58:04 * @最近更新: 芮正云 16396@etransfar.com * @更新时间: 2019-12-28 16:58:04 * @文件描述: 工具库 */ const fs = require('fs'); const Promise = require('bluebird'); // access_token 读操作 exports.readFileAsync = (fpath, encoding) => { return new Promise((resolve, reject) => { fs.readFile(fpath, encoding, function(err, content) { if (err) { reject(err); } else { resolve(content); } }); }); }; // access_token 写操作 exports.writeFileAsync = (fpath, content) => { return new Promise((resolve, reject) => { fs.writeFile(fpath, content, function(err, content) { if (err) { reject(err); } else { resolve(); } }); }); }; 4.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址 5.你会发现 /app-3/config/access-token.txt 文件生成 access_token 信息内容 版本四，实现自动回复 这次我们要实现，关注公众号后自动回复订阅成功的消息。 实现流程 处理 POST 类型的控制逻辑，接收这个 XML 数据包； 解析 XML 数据包； 拼写需要定义的消息； 包装成 XML 格式； 5 秒内返回回去； 测试号二维码 关注公众号后 关注公众号后 ToUserName，接收方账号； FromUserName，发送方账号，即 openid； CreateTime，发送消息时间； MsgType，消息类型。 代码实现 1.启动项 // app-4.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 启动项文件，版本四 */ const Koa = require('koa'); const path = require('path'); const fileAsync = require('./app-4/util/fileAsync'); const weChatMiddleWare = require('./app-4/middleWare/weChat'); const wechat_file = path.join(__dirname, './app-4/config/access-token.txt'); // 配置文件 const config = { wechat: { appID: 'wxb284d7a53fa2da16', appSecret: '24af419d8f6c997b5582fd46eafb377c', token: 'ruizhengyunpr840690384', getAccessToken: () => { // 读取文件 return fileAsync.readFileAsync(wechat_file); }, saveAccessToken: data => { // 写入文件 return fileAsync.writeFileAsync(wechat_file, JSON.stringify(data)); } } }; const PORT = 1989; const app = new Koa(); // 中间件 app.use(weChatMiddleWare(config.wechat)); app.listen(PORT); console.log(`正在监听：${PORT}`); 2.编写中间件 // app-4/middleWare/weChat.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const sha1 = require('sha1'); const rawBody = require('raw-body'); const fileAsync = require('../util/fileAsync'); const AccessTokenInfo = require('../util/AccessTokenInfo'); // 中间件 module.exports = function(opts) { const accessTokenInfo = new AccessTokenInfo(opts); return function*(next) { console.log('query', this.query); const token = opts.token; const signature = this.query.signature; const nonce = this.query.nonce; const timestamp = this.query.timestamp; const echostr = this.query.echostr; const str = [token, timestamp, nonce].sort().join(''); const sha = sha1(str); /** * GET 验证开发者身份 * POST */ if (sha !== signature) { this.body = '❌'; return false; } if (this.method === 'GET') { this.body = echostr + ''; } else if (this.method === 'POST') { // 依赖包 raw-body 可以把 this 上的 request 对象（http 模块中的 request 对象），拼写它的数据，最终拿到一个 buffer 的 XML const data = yield rawBody(this.req, { length: this.length, limit: '1mb', encoding: this.charset }); const content = yield fileAsync.parseXMLAsync(data); const message = fileAsync.formatMessage(content.xml); if (message.MsgType === 'event') { if (message.Event === 'subscribe') { const now = new Date().getTime(); this.status = 200; this.type = 'application/xml'; // 文本模板，后面可以把这块业务抽离处理 this.body = ` ${now} 1234567890123456 `; console.log('message', this.body); return; } } console.log('message', message); } }; }; 3.编写工具库 // app-4/uitl/fileAsync.js /** * @创建码农: pr * @创建日期: 2019-12-29 16:58:04 * @最近更新: pr * @更新时间: 2019-12-29 16:58:04 * @文件描述: 工具库 */ const fs = require('fs'); const Promise = require('bluebird'); const xml2js = require('xml2js'); // access_token 读操作 exports.readFileAsync = (fpath, encoding) => { return new Promise((resolve, reject) => { fs.readFile(fpath, encoding, function(err, content) { if (err) { reject(err); } else { resolve(content); } }); }); }; // access_token 写操作 exports.writeFileAsync = (fpath, content) => { return new Promise((resolve, reject) => { fs.writeFile(fpath, content, function(err, content) { if (err) { reject(err); } else { resolve(); } }); }); }; // 格式化 xml 消息 function formatMessage(data) { const message = {}; if (typeof data === 'object') { const keys = Object.keys(data); for (let i = 0; i // app-4/util/AccessTokenInfo.js /** * @创建码农: pr * @创建日期: 2019-12-29 19:47:02 * @最近更新: pr * @更新时间: 2019-12-29 19:47:02 * @文件描述: 公众号校验中间件 */ // 依赖包引入 const Promise = require('bluebird'); const request = Promise.promisify(require('request')); // 参数定义 const prefix = 'https://api.weixin.qq.com/cgi-bin/'; const api = { accessToken: `${prefix}token?grant_type=client_credential` }; // 判断 access_token 是否过期 function AccessTokenInfo(opts) { const that = this; this.appID = opts.appID; this.appSecret = opts.appSecret; this.getAccessToken = opts.getAccessToken; this.saveAccessToken = opts.saveAccessToken; that.getAccessToken().then(function(data) { try { data = JSON.parse(data); } catch (e) { // 不合法就重新更新 access_token return that.updateAccessToken(); } if (that.isValidAccessToken(data)) { //判断是否有效 // Promise.resolve(data); // 取到合法 access_token that.access_token = data.access_token; that.expires_in = data.expires_in; that.saveAccessToken(data); } else { // 不合法就重新更新 access_token return that.updateAccessToken(); } }); // .then(function(data) { // // 取到合法 access_token // that.access_token = data.access_token; // that.expires_in = data.expires_in; // that.saveAccessToken(data); // }); } // 验证 access_token 是否有效 AccessTokenInfo.prototype.isValidAccessToken = function(data) { if (!data || !data.access_token || !data.expires_in) { return false; } const now = new Date().getTime(); if (now { request({ url, json: true }).then(res => { const data = res.body; const now = new Date().getTime(); // 缩短 20 秒（算上网络请求时间） const expires_in = now + (data.expires_in - 20) * 1000; data.expires_in = expires_in; resolve(data); }); }); }; module.exports = AccessTokenInfo; 5.本地启动、ngrok 启动代理本地服务、拷贝 ngrok 产生的 https 地址 6.扫描关注公众号 文档和示例地址 github 地址 欢迎评论 你可以 上一篇：本地访问和外网访问 Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2020-01-04 17:45:26 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"message_encapsulation.html":{"url":"message_encapsulation.html","title":"消息封装","keywords":"","body":"消息封装 在上节，我们稍稍尝到了点甜头（订阅后自动回复），本章将实现更多有用的功能。 [x] 上传临时素材之图片和视频; Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2020-01-04 17:50:09 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"2019.html":{"url":"2019.html","title":"2019 年终总结","keywords":"","body":"2019 年终总结 时间过得真快，把我们带到 2019 年的最后一天。怎么也没想到今年的最后一天是在医院中度过的，每次进医院，都蓦然对生命发起敬畏之情，它是如此渺小与珍贵。 年中的一天（6月18日），意气风发地决定接下来的每天要在掘金上输出些东西，有幸收到掘金上小伙伴的支持与点赞，借着初心的新鲜动力和被认可的骄傲荣耀，坚持了三个月，不得不说有目的地做着自己喜欢的事，是多么幸运与知足。接下来的一个紧急项目、第四季度项目及考核这类事，劳心劳累让内心深处的懒惰成了主角。从 10 月到现在，寥寥几篇文章的产出，实在汗颜。年底了，搭乘这末班车的动力，决定继续输出，让不断学习、热爱输出成为生活的习惯和一部分，和吃饭、睡觉打豆豆无异。 今年做成了的事 写小书 前端面试之道，通过习题形式来考察知识能力。 前端架构小书，今年从前端转架构，虽然说架构类的工作不是很多，但是迈出第一步总是好的，后续文章再慢慢加上吧。 Dva小书，基本都来自 Dva 官网文档，只不过觉得官方文档不够简洁和不具结构性，所以用自己的语言和想法整理了下。 React 从入门到入坑再出门左拐写了一半，未输出部分大纲已列出，来年续上。 http 知多少，顺带着写，目前写了 2 篇吧。 Git 小书，写了一半，未输出部分大纲已列出，来年续上。 Typescript 小书，Demo 和个人项目操练了一遍，公司项目中还未应用，原因嘛，各有不同。 Chrome 小书，本小书是学习掘金小册，然后自己玩过一遍，觉得好玩的东西全部移植过来。 写文章 文章输出形式，本地使用 Markdown 文档格式书写，然后使用 gitbook 发布到编程之上，然后再发布到 github issues 和掘金等平台上； 文章数量 88 篇，真不是凑得，很好的数字，来年至少得有 2 倍的输出； 读书 《万物静默如谜》 《时间的朋友》 《激荡四十年》 《穷忙》 《无人生还》 《刘慈欣经典作品集》 《想我苦哈哈的一生》 《弗兰肯斯坦》 《天意》 《海边的卡夫卡》 《专业主义》 《浮生六级》 《明朝那些事儿》 《一直特立独行的猪》 《重新理解创业》 《地海传奇》 《第二十二条军规》 《那些年，马云犯过的错误》 《腾讯传》 《霍乱时期的爱情》 《江山美色》 今年没做完的事 和比人合作的小程序 年初做的，战线时间拖得太长，耗尽所有的激情，最终不了了之，但并不是毫无意义，积攒了经验和教训。 少儿编程项目 一个很有想法和创意的项目，本来想做好了，给身边有小孩朋友推广推广的，但是因为一些原因没有继续，不过这个想法本身份还是不错的，自己也有了一些想法的积累。后期可以作为一个点发散。 React 源码解析 现在想来，这个小书被延期的原因大抵是工作调动，从开发做架构，许多工作梳理导致的，但扪心自问还是自身的懒惰和对其优先级排名导致延期的。新的一年，这个要完善掉，立个 flag。 今年计划了没做的事 掘金小册 今年本打算出个小册的，至于定价少于 9.9 元吧，其实价钱都是没考虑的，主要是想锻炼和求证自己的写作水平。 薅羊毛站点 在 github 上做了 project dashboard，但一直未付诸于实施，主要是想一次性到位做的趋于完美。其实，对于《大教堂与集市》，理性是我选择集市，感性更倾向于大教堂，来年还是以集市思想去慢慢打造。 中后台项目开发助手及专利 这个也是基于一些开源项目产生的想法，具体等有了雏形再拿出来说吧。 比较火的技术 并不一定是今年的产物，下面要说的估计你都听过，不过我就当你不知道，重新梳理下。 React && React Hooks 2019 年 NPM 库下载量，React 再次荣登前端流行库榜首，用户数量还在不断增长。能保持第一位，React hooks 贡献满满。 WebAssembly WebAssembly 是一种新的字节码格式，目前主流浏览器都已经支WebAssembly。是由主流浏览器厂商组成的 W3C 社区团体制定的一个新的规范。可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。可以突破前端 3D game、 VR/AR 、 机器视觉、图像处理等运行速度瓶颈。 和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似，可以快速装载运行，因此性能相对于 JS 解释执行而言有了极大的提升。也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行，浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。有了 WebAssembly，在浏览器上可以跑任何语言。从 Coffee 到 TypeScript，到 Babel，这些都是需要转译为 js 才能被执行的，而 WebAssembly 是在浏览器里嵌入 vm，直接执行，不需要转译，执行效率自然高得多。 Typescript 或许你所在团队已经用烂了，但并不影响它作为一门比较🔥的技术在推广。TypeScript 席卷了整个 Web 前端和后端。TypeScript 已证明可以解决 JS 开发人员面临的一大核心问题，其使用率看来只增不减。TypeScript 与所有主流文本编辑器的集成，为 Web 开发人员提供了更好的开发体验。JavaScript 开发人员将 TypeScript 视为一种工具，减少错误，通过（提供自带描述的）类型和对象接口更轻松地读取代码。 Flutter 作为构建跨平台移动应用的另一个绝佳选择向 React Native 发起了挑战。 PWA 下一代 Web 应用。先说下当下 WebAPP 和 原生 APP。Web APP 对比 原生APP，开发成本低，适配多种移动设备，不用 IOS/安卓 多套代码，迭代更新容易，省去了审核、发包、各种渠道发布带来的时间损耗，无需安装成本，拿来即用。原生 APP也有它独到的优势，这些是 WebApp 所没有的优势我们也不知道以后会不会有突破。 PWA 能够显著提高应用加载速度，甚至让 web 应用可以在离线环境使用（Service Worker）。Web 应用能够像原生应用一样被添加到主屏、全屏执行 （Web App Manifest）进一步提高 Web 应用与操作系统集成能力，让 Web 应用能在未被激活时发起推送通知 （Push API 与 Notification API） 等等。 Serverless 其出名可以归因于前端。因为 Serverless 能够较完美的⽀持 Node.js，使⽤ Serverless 帮助前端开发者解决了使用 Node.js 过程中的诸多问题。当前的前端工程师大多都是科班出身，虽不能和正宗的服务端开发同学比，但也可写很多服务端层的业务逻辑。当前已经有很多公司在做 BFF 层，来满足这部分诉求，但依旧摆脱不掉运维、机器分配这条拦路虎。随着 Serverless 的逐步落地，BFF 这层的代码会摆脱运维、机器分配等复杂的问题，同时大概率会由前端同学写这部分代码，服务端同学专注中台系统的实现。从业务上说，业务的试错成本也会大幅度降低。 随着 Node.js 成为前端开发者必备技能之后，云计算的不断普及会让 Serverless 触不可及。当越来越多的开发者尝到研发⾼效的甜头之后，Serverless 必将对前端的研发模式产生变化 同时，使用 Serverless 的同学一定会使用 TS。这也意味着，2020 不写 TS 可能真的就 Out 了。 ES2019 ES2019 带来的新特性，提前拥抱未来 Javascript。 GraphQL GraphQL 是一种新的 API 定义和查询语言，有可能成为新的 REST。它使 UI 组件易于声明式地获取数据，而不必关注后端实现细节。GraphQL 作为一种强大的抽象，可以加快应用开发速度，使代码更容易维护。新的一年，会作为技术点研究并在自己项目试用。 CSS-in-Js 就是在组件内部使用 JavaScript 对 CSS 进行了抽象，可以对其声明和加以维护。这样不仅降低了编写 CSS 样式带来的风险，也让开发变得更加轻松。 新的一年计划 基础知识整理，细拆并计划; 感兴趣知识的调研，兴趣和实用第一位； 读书，专业工具书和兴趣爱好书阅读量达到 40 本； Copyright © ruizhengyun.cn 2019 all right reserved，powered by Gitbook修订时间： 2019-12-31 22:41:51 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}